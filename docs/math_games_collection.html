<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>一年级数学游戏乐园</title>
    <style>
        body {
            font-family: 'Comic Sans MS', 'Microsoft YaHei', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #FFE4E1 0%, #E0F6FF 50%, #98FB98 100%);
            min-height: 100vh;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #FF6B6B;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            margin-bottom: 10px;
            animation: bounce 2s infinite;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        
        .game-selector {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .game-button {
            background: rgba(255,255,255,0.9);
            border: 3px solid #FF6B6B;
            border-radius: 15px;
            padding: 15px 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.2em;
            font-weight: bold;
            color: #FF6B6B;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .game-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            background: #FF6B6B;
            color: white;
        }
        
        .game-button.active {
            background: #FF6B6B;
            color: white;
        }
        
        .game-container {
            background: rgba(255,255,255,0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            max-width: 900px;
            margin: 0 auto;
        }
        
        canvas {
            border: 4px solid #FF6B6B;
            border-radius: 15px;
            display: block;
            margin: 20px auto;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .game-info {
            text-align: center;
            margin: 20px 0;
        }
        
        .score-board {
            background: rgba(255,255,255,0.9);
            border-radius: 15px;
            padding: 15px;
            margin: 20px auto;
            max-width: 400px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            text-align: center;
        }
        
        .score-board h3 {
            color: #FF6B6B;
            margin: 0 0 10px 0;
        }
        
        .difficulty-selector {
            text-align: center;
            margin: 20px 0;
        }
        
        .difficulty-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
        }
        
        .difficulty-btn:hover {
            background: #45a049;
        }
        
        .difficulty-btn.active {
            background: #FF6B6B;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🎮 一年级数学游戏乐园 🎮</h1>
        <p>选择你喜欢的游戏开始学习吧！</p>
    </div>
    
    <div class="game-selector">
        <div class="game-button active" onclick="switchGame('frog')">🐸 青蛙跳荷叶</div>
        <div class="game-button" onclick="switchGame('monkey')">🐵 小猴分水果</div>
        <div class="game-button" onclick="switchGame('balance')">⚖️ 数字天平</div>
        <div class="game-button" onclick="switchGame('chain')">🔗 算式接龙</div>
        <div class="game-button" onclick="switchGame('bubble')">💭 数字泡泡</div>
        <div class="game-button" onclick="switchGame('car')">🚗 汽车停车场</div>
        <div class="game-button" onclick="switchGame('star')">⭐ 星星收集器</div>
        <div class="game-button" onclick="switchGame('balloon')">🎈 气球配对</div>
    </div>
    
    <div class="game-container">
        <div class="difficulty-selector">
            <button class="difficulty-btn active" onclick="setDifficulty('easy')">简单 (1-10)</button>
            <button class="difficulty-btn" onclick="setDifficulty('medium')">中等 (1-50)</button>
            <button class="difficulty-btn" onclick="setDifficulty('hard')">困难 (1-100)</button>
        </div>
        
        <div class="score-board">
            <h3 id="gameTitle">🐸 青蛙跳荷叶</h3>
            <p id="gameDescription">帮助小青蛙按照数字顺序跳荷叶回家！</p>
            <p><strong>得分：<span id="score">0</span></strong></p>
            <p id="gameHint">点击最小的数字开始！</p>
        </div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="game-info" id="gameInstructions">
            <p><strong>游戏说明：</strong>点击荷叶上的数字，按从小到大的顺序帮助青蛙跳回家！</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let currentGame = 'frog';
        let difficulty = 'easy';
        let score = 0;
        let animationFrame = 0;
        let gameState = {};
        
        // 难度设置
        const difficultySettings = {
            easy: { min: 1, max: 10, count: 5 },
            medium: { min: 1, max: 50, count: 7 },
            hard: { min: 1, max: 100, count: 10 }
        };
        
        // 游戏配置
        const gameConfigs = {
            frog: {
                title: '🐸 青蛙跳荷叶',
                description: '帮助小青蛙按照数字顺序跳荷叶回家！',
                instructions: '点击荷叶上的数字，按从小到大的顺序帮助青蛙跳回家！'
            },
            monkey: {
                title: '🐵 小猴分水果',
                description: '帮助小猴子解决加减法问题分水果！',
                instructions: '看题目选择正确答案，帮小猴子分水果给朋友们！'
            },
            balance: {
                title: '⚖️ 数字天平',
                description: '在天平两边放数字，让等式成立！',
                instructions: '拖拽数字到天平上，让左边和右边相等！'
            },
            chain: {
                title: '🔗 算式接龙',
                description: '按顺序点击算式，让数字接龙成功！',
                instructions: '从起始数字开始，按照加减法规律点击下一个数字！'
            },
            bubble: {
                title: '💭 数字泡泡',
                description: '点击正确答案的泡泡，让它们消失！',
                instructions: '计算算式结果，点击正确答案的泡泡！'
            },
            car: {
                title: '🚗 汽车停车场',
                description: '把不同形状的汽车停到对应的车位！',
                instructions: '拖拽汽车到相同形状的车位上！'
            },
            star: {
                title: '⭐ 星星收集器',
                description: '比较两个数字大小，选择更大的收集星星！',
                instructions: '点击两个数字中较大的那个来收集星星！'
            },
            balloon: {
                title: '🎈 气球配对',
                description: '找到相同数字的气球让它们配对！',
                instructions: '点击两个相同数字的气球让它们配对消失！'
            }
        };
        
        function switchGame(game) {
            currentGame = game;
            
            // 更新按钮状态
            document.querySelectorAll('.game-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // 更新游戏信息
            const config = gameConfigs[game];
            document.getElementById('gameTitle').textContent = config.title;
            document.getElementById('gameDescription').textContent = config.description;
            document.getElementById('gameInstructions').innerHTML = `<p><strong>游戏说明：</strong>${config.instructions}</p>`;
            
            // 重置游戏
            initGame();
        }
        
        function setDifficulty(level) {
            difficulty = level;
            
            // 更新按钮状态
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // 重新初始化游戏
            initGame();
        }
        
        function updateScore(points) {
            score += points;
            document.getElementById('score').textContent = score;
        }
        
        function updateHint(text) {
            document.getElementById('gameHint').textContent = text;
        }
        
        // 游戏初始化
        function initGame() {
            score = 0;
            document.getElementById('score').textContent = score;
            
            switch(currentGame) {
                case 'frog':
                    initFrogGame();
                    break;
                case 'monkey':
                    initMonkeyGame();
                    break;
                case 'balance':
                    initBalanceGame();
                    break;
                case 'chain':
                    initChainGame();
                    break;
                case 'bubble':
                    initBubbleGame();
                    break;
                case 'car':
                    initCarGame();
                    break;
                case 'star':
                    initStarGame();
                    break;
                case 'balloon':
                    initBalloonGame();
                    break;
            }
        }
        
        // 青蛙跳荷叶游戏
        function initFrogGame() {
            const settings = difficultySettings[difficulty];
            const numbers = [];
            
            // 生成随机数字
            while(numbers.length < settings.count) {
                const num = Math.floor(Math.random() * (settings.max - settings.min + 1)) + settings.min;
                if(!numbers.includes(num)) {
                    numbers.push(num);
                }
            }
            
            gameState = {
                numbers: numbers.sort((a, b) => Math.random() - 0.5), // 打乱顺序
                correctOrder: numbers.sort((a, b) => a - b),
                currentIndex: 0,
                frogX: 50,
                frogY: 300,
                lilypads: []
            };
            
            // 生成荷叶位置
            for(let i = 0; i < numbers.length; i++) {
                gameState.lilypads.push({
                    x: 150 + (i % 3) * 200 + Math.random() * 50,
                    y: 200 + Math.floor(i / 3) * 150 + Math.random() * 50,
                    number: gameState.numbers[i],
                    clicked: false
                });
            }
            
            updateHint(`点击数字 ${gameState.correctOrder[0]} 开始！`);
        }
        
        function drawFrogGame() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制背景
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#98FB98');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制荷叶
            gameState.lilypads.forEach(pad => {
                ctx.save();
                ctx.translate(pad.x, pad.y);
                
                // 荷叶
                ctx.fillStyle = pad.clicked ? '#90EE90' : '#228B22';
                ctx.beginPath();
                ctx.ellipse(0, 0, 40, 30, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 数字
                ctx.font = 'bold 20px Comic Sans MS';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(pad.number, 0, 0);
                
                ctx.restore();
            });
            
            // 绘制青蛙
            drawFrog(gameState.frogX, gameState.frogY);
            
            // 绘制家
            drawHome(750, 100);
        }
        
        function drawFrog(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // 青蛙身体
            ctx.fillStyle = '#32CD32';
            ctx.beginPath();
            ctx.ellipse(0, 0, 25, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 眼睛
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-8, -10, 6, 0, Math.PI * 2);
            ctx.arc(8, -10, 6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(-8, -10, 3, 0, Math.PI * 2);
            ctx.arc(8, -10, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawHome(x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(-30, -20, 60, 40);
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.moveTo(0, -40);
            ctx.lineTo(-35, -20);
            ctx.lineTo(35, -20);
            ctx.closePath();
            ctx.fill();
            
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.fillStyle = '#FFD700';
            ctx.textAlign = 'center';
            ctx.fillText('🏠', 0, 0);
            ctx.restore();
        }
        
        // 小猴分水果游戏
        function initMonkeyGame() {
            const settings = difficultySettings[difficulty];
            
            // 生成加减法题目
            const a = Math.floor(Math.random() * (settings.max / 2)) + 1;
            const b = Math.floor(Math.random() * (settings.max / 2)) + 1;
            const operation = Math.random() < 0.5 ? '+' : '-';
            const correctAnswer = operation === '+' ? a + b : Math.max(a, b) - Math.min(a, b);
            
            // 生成错误答案
            const wrongAnswers = [];
            while(wrongAnswers.length < 2) {
                const wrong = correctAnswer + (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 5) + 1);
                if(wrong > 0 && wrong !== correctAnswer && !wrongAnswers.includes(wrong)) {
                    wrongAnswers.push(wrong);
                }
            }
            
            const allAnswers = [correctAnswer, ...wrongAnswers].sort(() => Math.random() - 0.5);
            
            gameState = {
                question: `${Math.max(a, b)} ${operation} ${Math.min(a, b)} = ?`,
                correctAnswer: correctAnswer,
                answers: allAnswers,
                fruits: []
            };
            
            // 生成水果位置
            for(let i = 0; i < 3; i++) {
                gameState.fruits.push({
                    x: 300 + i * 150,
                    y: 300,
                    answer: allAnswers[i],
                    type: ['🍎', '🍌', '🍊'][i]
                });
            }
            
            updateHint(`解决这个问题：${gameState.question}`);
        }
        
        function drawMonkeyGame() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制背景
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#FFE4B5');
            gradient.addColorStop(1, '#98FB98');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制题目
            ctx.font = 'bold 30px Comic Sans MS';
            ctx.fillStyle = '#8B4513';
            ctx.textAlign = 'center';
            ctx.fillText(gameState.question, canvas.width / 2, 80);
            
            // 绘制小猴子
            drawMonkey(100, 300);
            
            // 绘制水果选项
            gameState.fruits.forEach(fruit => {
                ctx.save();
                ctx.translate(fruit.x, fruit.y);
                
                // 水果背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.roundRect(-40, -40, 80, 80, 15);
                ctx.fill();
                
                // 水果图标
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(fruit.type, 0, -10);
                
                // 答案数字
                ctx.font = 'bold 24px Comic Sans MS';
                ctx.fillStyle = '#8B4513';
                ctx.fillText(fruit.answer, 0, 25);
                
                ctx.restore();
            });
        }
        
        function drawMonkey(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // 猴子身体
            ctx.fillStyle = '#DEB887';
            ctx.beginPath();
            ctx.ellipse(0, 0, 30, 40, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 猴子头
            ctx.beginPath();
            ctx.arc(0, -50, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // 眼睛
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-8, -55, 5, 0, Math.PI * 2);
            ctx.arc(8, -55, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(-8, -55, 2, 0, Math.PI * 2);
            ctx.arc(8, -55, 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // 数字天平游戏
        function initBalanceGame() {
            const settings = difficultySettings[difficulty];
            
            // 生成目标等式
            const target = Math.floor(Math.random() * (settings.max / 2)) + 5;
            const leftSide = Math.floor(Math.random() * target) + 1;
            const rightSide = target - leftSide;
            
            gameState = {
                target: target,
                leftSide: leftSide,
                rightSide: rightSide,
                leftNumbers: [],
                rightNumbers: [],
                availableNumbers: [],
                draggedNumber: null,
                dragOffset: {x: 0, y: 0},
                balanced: false
            };
            
            // 生成可用数字
            const numbers = [leftSide, rightSide];
            while(numbers.length < 6) {
                const num = Math.floor(Math.random() * settings.max) + 1;
                if(!numbers.includes(num)) {
                    numbers.push(num);
                }
            }
            
            // 打乱顺序并创建可用数字
            numbers.sort(() => Math.random() - 0.5);
            for(let i = 0; i < numbers.length; i++) {
                gameState.availableNumbers.push({
                    value: numbers[i],
                    x: 100 + (i % 3) * 100,
                    y: 500 + Math.floor(i / 3) * 60,
                    used: false
                });
            }
            
            updateHint(`让天平平衡！目标：两边都等于 ${target}`);
        }
        
        function drawBalanceGame() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制背景
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#E6E6FA');
            gradient.addColorStop(1, '#F0F8FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制天平
            drawBalance();
            
            // 绘制可用数字
            gameState.availableNumbers.forEach(num => {
                if(!num.used) {
                    drawNumber(num.x, num.y, num.value, '#4169E1');
                }
            });
            
            // 绘制天平上的数字
            gameState.leftNumbers.forEach((num, index) => {
                drawNumber(250 + index * 40, 250, num, '#32CD32');
            });
            
            gameState.rightNumbers.forEach((num, index) => {
                drawNumber(450 + index * 40, 250, num, '#FF6347');
            });
        }
        
        function drawBalance() {
            // 天平支架
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(400, 150);
            ctx.lineTo(400, 350);
            ctx.stroke();
            
            // 天平横梁
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(200, 200);
            ctx.lineTo(600, 200);
            ctx.stroke();
            
            // 左盘
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(250, 250, 80, 0, Math.PI, false);
            ctx.lineTo(330, 250);
            ctx.lineTo(170, 250);
            ctx.closePath();
            ctx.fill();
            
            // 右盘
            ctx.beginPath();
            ctx.arc(550, 250, 80, 0, Math.PI, false);
            ctx.lineTo(630, 250);
            ctx.lineTo(470, 250);
            ctx.closePath();
            ctx.fill();
            
            // 支撑线
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(250, 200);
            ctx.lineTo(250, 250);
            ctx.moveTo(550, 200);
            ctx.lineTo(550, 250);
            ctx.stroke();
            
            // 显示当前总和
            const leftSum = gameState.leftNumbers.reduce((sum, num) => sum + num, 0);
            const rightSum = gameState.rightNumbers.reduce((sum, num) => sum + num, 0);
            
            ctx.font = 'bold 24px Comic Sans MS';
            ctx.fillStyle = '#8B4513';
            ctx.textAlign = 'center';
            ctx.fillText(`= ${leftSum}`, 250, 320);
            ctx.fillText(`= ${rightSum}`, 550, 320);
        }
        
        function drawNumber(x, y, value, color) {
            ctx.save();
            ctx.translate(x, y);
            
            // 数字背景
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();
            
            // 数字
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(value, 0, 0);
            
            ctx.restore();
        }
        
        // 算式接龙游戏
        function initChainGame() {
            const settings = difficultySettings[difficulty];
            
            // 生成算式序列
            let currentNum = Math.floor(Math.random() * (settings.max / 4)) + 5;
            const operations = ['+', '-'];
            const sequence = [currentNum];
            
            for(let i = 0; i < 4; i++) {
                const operation = operations[Math.random() < 0.5 ? 0 : 1];
                const operand = Math.floor(Math.random() * 10) + 1;
                
                if(operation === '+') {
                    currentNum += operand;
                } else {
                    currentNum = Math.max(1, currentNum - operand);
                }
                
                sequence.push(currentNum);
            }
            
            gameState = {
                sequence: sequence,
                currentIndex: 0,
                chains: [],
                completed: false
            };
            
            // 创建链条位置
            for(let i = 0; i < sequence.length; i++) {
                gameState.chains.push({
                    x: 150 + i * 120,
                    y: 300,
                    value: sequence[i],
                    clicked: false,
                    operation: i > 0 ? (sequence[i] > sequence[i-1] ? '+' : '-') : null,
                    operand: i > 0 ? Math.abs(sequence[i] - sequence[i-1]) : null
                });
            }
            
            updateHint(`从 ${sequence[0]} 开始，按顺序点击！`);
        }
        
        function drawChainGame() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制背景
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#FFF8DC');
            gradient.addColorStop(1, '#F0E68C');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制链条
            gameState.chains.forEach((chain, index) => {
                ctx.save();
                ctx.translate(chain.x, chain.y);
                
                // 链环
                const color = chain.clicked ? '#32CD32' : (index === gameState.currentIndex ? '#FFD700' : '#C0C0C0');
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // 数字
                ctx.font = 'bold 20px Comic Sans MS';
                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(chain.value, 0, 0);
                
                // 操作符
                if(index > 0 && chain.operation) {
                    ctx.font = 'bold 16px Comic Sans MS';
                    ctx.fillStyle = '#8B4513';
                    ctx.fillText(`${chain.operation}${chain.operand}`, -60, -10);
                }
                
                // 连接线
                if(index < gameState.chains.length - 1) {
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(30, 0);
                    ctx.lineTo(90, 0);
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }
        
        // 数字泡泡游戏
        function initBubbleGame() {
            const settings = difficultySettings[difficulty];
            
            gameState = {
                bubbles: [],
                targetEquation: null,
                correctAnswer: 0,
                poppedCount: 0
            };
            
            // 生成算式
            const a = Math.floor(Math.random() * (settings.max / 2)) + 1;
            const b = Math.floor(Math.random() * (settings.max / 2)) + 1;
            const operation = Math.random() < 0.5 ? '+' : '-';
            const correctAnswer = operation === '+' ? a + b : Math.max(a, b) - Math.min(a, b);
            
            gameState.targetEquation = `${Math.max(a, b)} ${operation} ${Math.min(a, b)} = ?`;
            gameState.correctAnswer = correctAnswer;
            
            // 生成泡泡
            const answers = [correctAnswer];
            while(answers.length < 8) {
                const wrong = correctAnswer + (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 10) + 1);
                if(wrong > 0 && !answers.includes(wrong)) {
                    answers.push(wrong);
                }
            }
            
            // 打乱并创建泡泡
            answers.sort(() => Math.random() - 0.5);
            for(let i = 0; i < answers.length; i++) {
                gameState.bubbles.push({
                    x: 150 + (i % 4) * 150,
                    y: 200 + Math.floor(i / 4) * 150,
                    value: answers[i],
                    isCorrect: answers[i] === correctAnswer,
                    popped: false,
                    size: 40,
                    color: `hsl(${Math.random() * 360}, 70%, 80%)`,
                    float: Math.random() * Math.PI * 2
                });
            }
            
            updateHint(`计算：${gameState.targetEquation}`);
        }
        
        function drawBubbleGame() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制背景
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制题目
            ctx.font = 'bold 32px Comic Sans MS';
            ctx.fillStyle = '#4169E1';
            ctx.textAlign = 'center';
            ctx.fillText(gameState.targetEquation, canvas.width / 2, 80);
            
            // 绘制泡泡
            gameState.bubbles.forEach(bubble => {
                if(!bubble.popped) {
                    const floatY = Math.sin(bubble.float + animationFrame * 0.02) * 3;
                    
                    ctx.save();
                    ctx.translate(bubble.x, bubble.y + floatY);
                    
                    // 泡泡主体
                    ctx.fillStyle = bubble.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, bubble.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 泡泡高光
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(-10, -10, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 数字
                    ctx.font = 'bold 24px Comic Sans MS';
                    ctx.fillStyle = 'black';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(bubble.value, 0, 0);
                    
                    ctx.restore();
                }
            });
        }
        
        // 汽车停车场游戏
        function initCarGame() {
            const shapes = ['circle', 'square', 'triangle'];
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1'];
            
            gameState = {
                cars: [],
                parkingSpots: [],
                draggedCar: null,
                dragOffset: {x: 0, y: 0}
            };
            
            // 生成停车位
            for(let i = 0; i < 3; i++) {
                gameState.parkingSpots.push({
                    x: 500 + i * 100,
                    y: 400,
                    shape: shapes[i],
                    occupied: false
                });
            }
            
            // 生成汽车
            const shuffledShapes = [...shapes].sort(() => Math.random() - 0.5);
            for(let i = 0; i < 3; i++) {
                gameState.cars.push({
                    x: 100 + i * 80,
                    y: 200,
                    shape: shuffledShapes[i],
                    color: colors[shapes.indexOf(shuffledShapes[i])],
                    parked: false
                });
            }
            
            updateHint('拖拽汽车到相同形状的车位！');
        }
        
        function drawCarGame() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制背景
            ctx.fillStyle = '#F0F0F0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制停车位
            gameState.parkingSpots.forEach(spot => {
                drawParkingSpot(spot);
            });
            
            // 绘制汽车
            gameState.cars.forEach(car => {
                if(!car.parked) {
                    drawCar(car);
                }
            });
        }
        
        function drawParkingSpot(spot) {
            ctx.save();
            ctx.translate(spot.x, spot.y);
            
            // 停车位背景
            ctx.fillStyle = spot.occupied ? '#90EE90' : '#DCDCDC';
            ctx.fillRect(-40, -30, 80, 60);
            
            // 形状轮廓
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            if(spot.shape === 'circle') {
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
            } else if(spot.shape === 'square') {
                ctx.rect(-15, -15, 30, 30);
            } else if(spot.shape === 'triangle') {
                ctx.moveTo(0, -15);
                ctx.lineTo(-15, 15);
                ctx.lineTo(15, 15);
                ctx.closePath();
            }
            
            ctx.stroke();
            ctx.restore();
        }
        
        function drawCar(car) {
            ctx.save();
            ctx.translate(car.x, car.y);
            
            // 汽车主体
            ctx.fillStyle = car.color;
            ctx.fillRect(-25, -15, 50, 30);
            
            // 汽车形状标识
            ctx.fillStyle = 'white';
            ctx.beginPath();
            
            if(car.shape === 'circle') {
                ctx.arc(0, 0, 10, 0, Math.PI * 2);
            } else if(car.shape === 'square') {
                ctx.rect(-8, -8, 16, 16);
            } else if(car.shape === 'triangle') {
                ctx.moveTo(0, -8);
                ctx.lineTo(-8, 8);
                ctx.lineTo(8, 8);
                ctx.closePath();
            }
            
            ctx.fill();
            
            // 车轮
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(-15, 15, 5, 0, Math.PI * 2);
            ctx.arc(15, 15, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // 星星收集器游戏
        function initStarGame() {
            const settings = difficultySettings[difficulty];
            
            const num1 = Math.floor(Math.random() * settings.max) + 1;
            let num2 = Math.floor(Math.random() * settings.max) + 1;
            while(num2 === num1) {
                num2 = Math.floor(Math.random() * settings.max) + 1;
            }
            
            gameState = {
                numbers: [num1, num2],
                correctAnswer: Math.max(num1, num2),
                stars: []
            };
            
            // 生成星星
            for(let i = 0; i < 10; i++) {
                gameState.stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * 200 + 50,
                    collected: false,
                    twinkle: Math.random() * Math.PI * 2
                });
            }
            
            updateHint(`选择更大的数字：${num1} 或 ${num2}`);
        }
        
        function drawStarGame() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制夜空背景
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#191970');
            gradient.addColorStop(1, '#4B0082');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制星星
            gameState.stars.forEach(star => {
                if(!star.collected) {
                    drawStar(star);
                }
            });
            
            // 绘制数字选项
            gameState.numbers.forEach((num, index) => {
                ctx.save();
                ctx.translate(200 + index * 400, 400);
                
                // 数字背景
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(-60, -60, 120, 120, 20);
                ctx.fill();
                
                // 数字
                ctx.font = 'bold 48px Comic Sans MS';
                ctx.fillStyle = '#4B0082';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(num, 0, 0);
                
                ctx.restore();
            });
        }
        
        function drawStar(star) {
            ctx.save();
            ctx.translate(star.x, star.y);
            
            const alpha = (Math.sin(star.twinkle + animationFrame * 0.1) + 1) / 2;
            ctx.globalAlpha = alpha * 0.8 + 0.2;
            ctx.fillStyle = '#FFD700';
            
            // 绘制五角星
            ctx.beginPath();
            for(let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5;
                const x = Math.cos(angle) * 8;
                const y = Math.sin(angle) * 8;
                if(i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
        // 气球配对游戏
        function initBalloonGame() {
            const settings = difficultySettings[difficulty];
            const numbers = [];
            
            // 生成配对数字
            const pairCount = Math.min(4, Math.floor(settings.count / 2));
            for(let i = 0; i < pairCount; i++) {
                const num = Math.floor(Math.random() * settings.max) + 1;
                numbers.push(num, num); // 添加一对相同的数字
            }
            
            // 打乱顺序
            numbers.sort(() => Math.random() - 0.5);
            
            gameState = {
                balloons: [],
                selectedBalloons: [],
                matchedPairs: 0,
                totalPairs: pairCount
            };
            
            // 生成气球
            numbers.forEach((num, index) => {
                gameState.balloons.push({
                    x: 150 + (index % 4) * 150,
                    y: 150 + Math.floor(index / 4) * 120,
                    number: num,
                    color: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'][index % 4],
                    selected: false,
                    matched: false,
                    float: Math.random() * Math.PI * 2
                });
            });
            
            updateHint('点击两个相同数字的气球配对！');
        }
        
        function drawBalloonGame() {
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制天空背景
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制气球
            gameState.balloons.forEach(balloon => {
                if(!balloon.matched) {
                    drawBalloon(balloon);
                }
            });
        }
        
        function drawBalloon(balloon) {
            ctx.save();
            
            const floatY = Math.sin(balloon.float + animationFrame * 0.02) * 5;
            ctx.translate(balloon.x, balloon.y + floatY);
            
            // 气球绳子
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 25);
            ctx.lineTo(0, 60);
            ctx.stroke();
            
            // 气球主体
            ctx.fillStyle = balloon.selected ? '#FFD700' : balloon.color;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // 气球高光
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(-8, -8, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // 数字
            ctx.font = 'bold 20px Comic Sans MS';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(balloon.number, 0, 0);
            
            ctx.restore();
        }
        
        // 事件处理
        canvas.addEventListener('click', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            switch(currentGame) {
                case 'frog':
                    handleFrogClick(x, y);
                    break;
                case 'monkey':
                    handleMonkeyClick(x, y);
                    break;
                case 'balance':
                    handleBalanceClick(x, y);
                    break;
                case 'chain':
                    handleChainClick(x, y);
                    break;
                case 'bubble':
                    handleBubbleClick(x, y);
                    break;
                case 'star':
                    handleStarClick(x, y);
                    break;
                case 'balloon':
                    handleBalloonClick(x, y);
                    break;
            }
        });
        
        // 拖拽事件处理（汽车游戏和天平游戏）
        canvas.addEventListener('mousedown', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if(currentGame === 'car') {
                gameState.cars.forEach(car => {
                    if(!car.parked && Math.abs(x - car.x) < 25 && Math.abs(y - car.y) < 15) {
                        gameState.draggedCar = car;
                        gameState.dragOffset = {x: x - car.x, y: y - car.y};
                    }
                });
            } else if(currentGame === 'balance') {
                gameState.availableNumbers.forEach(num => {
                    if(!num.used && Math.abs(x - num.x) < 20 && Math.abs(y - num.y) < 20) {
                        gameState.draggedNumber = num;
                        gameState.dragOffset = {x: x - num.x, y: y - num.y};
                    }
                });
            }
        });
        
        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if(currentGame === 'car' && gameState.draggedCar) {
                gameState.draggedCar.x = x - gameState.dragOffset.x;
                gameState.draggedCar.y = y - gameState.dragOffset.y;
            } else if(currentGame === 'balance' && gameState.draggedNumber) {
                gameState.draggedNumber.x = x - gameState.dragOffset.x;
                gameState.draggedNumber.y = y - gameState.dragOffset.y;
            }
        });
        
        canvas.addEventListener('mouseup', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if(currentGame === 'car' && gameState.draggedCar) {
                // 检查是否放到了正确的停车位
                gameState.parkingSpots.forEach(spot => {
                    if(!spot.occupied && 
                       Math.abs(x - spot.x) < 40 && 
                       Math.abs(y - spot.y) < 30 &&
                       spot.shape === gameState.draggedCar.shape) {
                        
                        gameState.draggedCar.parked = true;
                        spot.occupied = true;
                        updateScore(10);
                        
                        // 检查是否全部停好
                        if(gameState.cars.every(car => car.parked)) {
                            setTimeout(() => {
                                alert('🎉 太棒了！所有汽车都停好了！');
                                initGame();
                            }, 500);
                        }
                    }
                });
                
                gameState.draggedCar = null;
            } else if(currentGame === 'balance' && gameState.draggedNumber) {
                // 检查是否放到天平上
                if(x > 170 && x < 330 && y > 200 && y < 300) {
                    // 放到左盘
                    gameState.leftNumbers.push(gameState.draggedNumber.value);
                    gameState.draggedNumber.used = true;
                } else if(x > 470 && x < 630 && y > 200 && y < 300) {
                    // 放到右盘
                    gameState.rightNumbers.push(gameState.draggedNumber.value);
                    gameState.draggedNumber.used = true;
                }
                
                // 检查是否平衡
                const leftSum = gameState.leftNumbers.reduce((sum, n) => sum + n, 0);
                const rightSum = gameState.rightNumbers.reduce((sum, n) => sum + n, 0);
                
                if(leftSum === rightSum && leftSum === gameState.target) {
                    updateScore(25);
                    updateHint('太棒了！天平平衡了！');
                    setTimeout(() => {
                        alert('🎉 恭喜！天平完美平衡！');
                        initGame();
                    }, 1000);
                } else if(leftSum > 0 || rightSum > 0) {
                    updateHint(`左边：${leftSum}，右边：${rightSum}，目标：${gameState.target}`);
                }
                
                gameState.draggedNumber = null;
            }
        });
        
        // 各游戏的点击处理函数
        function handleFrogClick(x, y) {
            gameState.lilypads.forEach(pad => {
                if(Math.abs(x - pad.x) < 40 && Math.abs(y - pad.y) < 30 && !pad.clicked) {
                    if(pad.number === gameState.correctOrder[gameState.currentIndex]) {
                        pad.clicked = true;
                        gameState.currentIndex++;
                        updateScore(10);
                        
                        // 移动青蛙
                        gameState.frogX = pad.x;
                        gameState.frogY = pad.y;
                        
                        if(gameState.currentIndex < gameState.correctOrder.length) {
                            updateHint(`很好！现在点击数字 ${gameState.correctOrder[gameState.currentIndex]}`);
                        } else {
                            updateHint('太棒了！青蛙回家了！');
                            setTimeout(() => {
                                alert('🎉 恭喜！青蛙成功回家了！');
                                initGame();
                            }, 1000);
                        }
                    } else {
                        updateHint(`不对哦，应该点击数字 ${gameState.correctOrder[gameState.currentIndex]}`);
                    }
                }
            });
        }
        
        function handleMonkeyClick(x, y) {
            gameState.fruits.forEach(fruit => {
                if(Math.abs(x - fruit.x) < 40 && Math.abs(y - fruit.y) < 40) {
                    if(fruit.answer === gameState.correctAnswer) {
                        updateScore(15);
                        updateHint('太棒了！答案正确！');
                        setTimeout(() => {
                            alert('🎉 小猴子很开心！答案正确！');
                            initGame();
                        }, 1000);
                    } else {
                        updateHint('不对哦，再想想看！');
                    }
                }
            });
        }
        
        function handleStarClick(x, y) {
            gameState.numbers.forEach((num, index) => {
                const centerX = 200 + index * 400;
                const centerY = 400;
                
                if(Math.abs(x - centerX) < 60 && Math.abs(y - centerY) < 60) {
                    if(num === gameState.correctAnswer) {
                        // 收集所有星星
                        gameState.stars.forEach(star => star.collected = true);
                        updateScore(20);
                        updateHint('太棒了！收集了所有星星！');
                        
                        setTimeout(() => {
                            alert('🎉 恭喜！你选择了更大的数字！');
                            initGame();
                        }, 1000);
                    } else {
                        updateHint('不对哦，选择更大的数字！');
                    }
                }
            });
        }
        
        function handleBalloonClick(x, y) {
            gameState.balloons.forEach(balloon => {
                if(!balloon.matched && Math.abs(x - balloon.x) < 25 && Math.abs(y - balloon.y) < 25) {
                    if(gameState.selectedBalloons.length < 2) {
                        balloon.selected = true;
                        gameState.selectedBalloons.push(balloon);
                        
                        if(gameState.selectedBalloons.length === 2) {
                            const [first, second] = gameState.selectedBalloons;
                            
                            if(first.number === second.number) {
                                // 配对成功
                                first.matched = true;
                                second.matched = true;
                                gameState.matchedPairs++;
                                updateScore(15);
                                
                                if(gameState.matchedPairs === gameState.totalPairs) {
                                    setTimeout(() => {
                                        alert('🎉 太棒了！所有气球都配对成功了！');
                                        initGame();
                                    }, 1000);
                                }
                            } else {
                                // 配对失败，重置选择
                                setTimeout(() => {
                                    first.selected = false;
                                    second.selected = false;
                                }, 1000);
                            }
                            
                            gameState.selectedBalloons = [];
                        }
                    }
                }
            });
        }
        
        function handleBalanceClick(x, y) {
            // 检查点击的数字
            gameState.availableNumbers.forEach(num => {
                if(!num.used && Math.abs(x - num.x) < 20 && Math.abs(y - num.y) < 20) {
                    // 简化：点击数字直接添加到左盘
                    gameState.leftNumbers.push(num.value);
                    num.used = true;
                    
                    // 检查是否平衡
                    const leftSum = gameState.leftNumbers.reduce((sum, n) => sum + n, 0);
                    const rightSum = gameState.rightNumbers.reduce((sum, n) => sum + n, 0);
                    
                    if(leftSum === gameState.target && rightSum === 0) {
                        // 还需要右边
                        updateHint(`很好！现在右边也需要等于 ${gameState.target}`);
                    } else if(leftSum === gameState.target && rightSum === gameState.target) {
                        updateScore(25);
                        updateHint('太棒了！天平平衡了！');
                        setTimeout(() => {
                            alert('🎉 恭喜！天平完美平衡！');
                            initGame();
                        }, 1000);
                    } else if(leftSum > gameState.target) {
                        updateHint('左边太重了，试试其他组合！');
                        setTimeout(() => initGame(), 1500);
                    }
                }
            });
            
            // 简化版本：点击右盘区域添加到右盘
            if(x > 470 && x < 630 && y > 200 && y < 300) {
                gameState.availableNumbers.forEach(num => {
                    if(!num.used) {
                        gameState.rightNumbers.push(num.value);
                        num.used = true;
                        
                        const leftSum = gameState.leftNumbers.reduce((sum, n) => sum + n, 0);
                        const rightSum = gameState.rightNumbers.reduce((sum, n) => sum + n, 0);
                        
                        if(leftSum === rightSum && leftSum === gameState.target) {
                            updateScore(25);
                            updateHint('太棒了！天平平衡了！');
                            setTimeout(() => {
                                alert('🎉 恭喜！天平完美平衡！');
                                initGame();
                            }, 1000);
                        }
                        return;
                    }
                });
            }
        }
        
        function handleChainClick(x, y) {
            gameState.chains.forEach((chain, index) => {
                if(Math.abs(x - chain.x) < 30 && Math.abs(y - chain.y) < 30) {
                    if(index === gameState.currentIndex) {
                        chain.clicked = true;
                        gameState.currentIndex++;
                        updateScore(10);
                        
                        if(gameState.currentIndex < gameState.chains.length) {
                            updateHint(`很好！下一个是 ${gameState.chains[gameState.currentIndex].value}`);
                        } else {
                            updateHint('太棒了！算式接龙完成！');
                            gameState.completed = true;
                            setTimeout(() => {
                                alert('🎉 恭喜！算式接龙成功完成！');
                                initGame();
                            }, 1000);
                        }
                    } else {
                        updateHint(`不对哦，应该点击 ${gameState.chains[gameState.currentIndex].value}`);
                    }
                }
            });
        }
        
        function handleBubbleClick(x, y) {
            gameState.bubbles.forEach(bubble => {
                if(!bubble.popped && Math.abs(x - bubble.x) < bubble.size && Math.abs(y - bubble.y) < bubble.size) {
                    if(bubble.isCorrect) {
                        bubble.popped = true;
                        gameState.poppedCount++;
                        updateScore(15);
                        updateHint('太棒了！答案正确！');
                        
                        setTimeout(() => {
                            alert('🎉 恭喜！你找到了正确答案！');
                            initGame();
                        }, 1000);
                    } else {
                        updateHint('不对哦，再想想看！');
                        // 错误的泡泡也会消失，但不得分
                        bubble.popped = true;
                    }
                }
            });
        }
        
        // 游戏主循环
        function gameLoop() {
            switch(currentGame) {
                case 'frog':
                    drawFrogGame();
                    break;
                case 'monkey':
                    drawMonkeyGame();
                    break;
                case 'balance':
                    drawBalanceGame();
                    break;
                case 'chain':
                    drawChainGame();
                    break;
                case 'bubble':
                    drawBubbleGame();
                    break;
                case 'car':
                    drawCarGame();
                    break;
                case 'star':
                    drawStarGame();
                    break;
                case 'balloon':
                    drawBalloonGame();
                    break;
            }
            
            animationFrame++;
            requestAnimationFrame(gameLoop);
        }
        
        // 添加圆角矩形支持
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
                this.beginPath();
                this.moveTo(x + radius, y);
                this.lineTo(x + width - radius, y);
                this.quadraticCurveTo(x + width, y, x + width, y + radius);
                this.lineTo(x + width, y + height - radius);
                this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                this.lineTo(x + radius, y + height);
                this.quadraticCurveTo(x, y + height, x, y + height - radius);
                this.lineTo(x, y + radius);
                this.quadraticCurveTo(x, y, x + radius, y);
                this.closePath();
            };
        }
        
        // 初始化游戏
        initGame();
        gameLoop();
    </script>
</body>
</html> 