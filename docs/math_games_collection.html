<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ä¸€å¹´çº§æ•°å­¦æ¸¸æˆä¹å›­</title>
    <style>
        body {
            font-family: 'Comic Sans MS', 'Microsoft YaHei', sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #FFE4E1 0%, #E0F6FF 50%, #98FB98 100%);
            min-height: 100vh;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #FF6B6B;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            margin-bottom: 10px;
            animation: bounce 2s infinite;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        
        .game-selector {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .game-button {
            background: rgba(255,255,255,0.9);
            border: 3px solid #FF6B6B;
            border-radius: 15px;
            padding: 15px 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.2em;
            font-weight: bold;
            color: #FF6B6B;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .game-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            background: #FF6B6B;
            color: white;
        }
        
        .game-button.active {
            background: #FF6B6B;
            color: white;
        }
        
        .game-container {
            background: rgba(255,255,255,0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            max-width: 900px;
            margin: 0 auto;
        }
        
        canvas {
            border: 4px solid #FF6B6B;
            border-radius: 15px;
            display: block;
            margin: 20px auto;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .game-info {
            text-align: center;
            margin: 20px 0;
        }
        
        .score-board {
            background: rgba(255,255,255,0.9);
            border-radius: 15px;
            padding: 15px;
            margin: 20px auto;
            max-width: 400px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            text-align: center;
        }
        
        .score-board h3 {
            color: #FF6B6B;
            margin: 0 0 10px 0;
        }
        
        .difficulty-selector {
            text-align: center;
            margin: 20px 0;
        }
        
        .difficulty-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
        }
        
        .difficulty-btn:hover {
            background: #45a049;
        }
        
        .difficulty-btn.active {
            background: #FF6B6B;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ® ä¸€å¹´çº§æ•°å­¦æ¸¸æˆä¹å›­ ğŸ®</h1>
        <p>é€‰æ‹©ä½ å–œæ¬¢çš„æ¸¸æˆå¼€å§‹å­¦ä¹ å§ï¼</p>
    </div>
    
    <div class="game-selector">
        <div class="game-button active" onclick="switchGame('frog')">ğŸ¸ é’è›™è·³è·å¶</div>
        <div class="game-button" onclick="switchGame('monkey')">ğŸµ å°çŒ´åˆ†æ°´æœ</div>
        <div class="game-button" onclick="switchGame('balance')">âš–ï¸ æ•°å­—å¤©å¹³</div>
        <div class="game-button" onclick="switchGame('chain')">ğŸ”— ç®—å¼æ¥é¾™</div>
        <div class="game-button" onclick="switchGame('bubble')">ğŸ’­ æ•°å­—æ³¡æ³¡</div>
        <div class="game-button" onclick="switchGame('car')">ğŸš— æ±½è½¦åœè½¦åœº</div>
        <div class="game-button" onclick="switchGame('star')">â­ æ˜Ÿæ˜Ÿæ”¶é›†å™¨</div>
        <div class="game-button" onclick="switchGame('balloon')">ğŸˆ æ°”çƒé…å¯¹</div>
    </div>
    
    <div class="game-container">
        <div class="difficulty-selector">
            <button class="difficulty-btn active" onclick="setDifficulty('easy')">ç®€å• (1-10)</button>
            <button class="difficulty-btn" onclick="setDifficulty('medium')">ä¸­ç­‰ (1-50)</button>
            <button class="difficulty-btn" onclick="setDifficulty('hard')">å›°éš¾ (1-100)</button>
        </div>
        
        <div class="score-board">
            <h3 id="gameTitle">ğŸ¸ é’è›™è·³è·å¶</h3>
            <p id="gameDescription">å¸®åŠ©å°é’è›™æŒ‰ç…§æ•°å­—é¡ºåºè·³è·å¶å›å®¶ï¼</p>
            <p><strong>å¾—åˆ†ï¼š<span id="score">0</span></strong></p>
            <p id="gameHint">ç‚¹å‡»æœ€å°çš„æ•°å­—å¼€å§‹ï¼</p>
        </div>
        
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="game-info" id="gameInstructions">
            <p><strong>æ¸¸æˆè¯´æ˜ï¼š</strong>ç‚¹å‡»è·å¶ä¸Šçš„æ•°å­—ï¼ŒæŒ‰ä»å°åˆ°å¤§çš„é¡ºåºå¸®åŠ©é’è›™è·³å›å®¶ï¼</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let currentGame = 'frog';
        let difficulty = 'easy';
        let score = 0;
        let animationFrame = 0;
        let gameState = {};
        
        // éš¾åº¦è®¾ç½®
        const difficultySettings = {
            easy: { min: 1, max: 10, count: 5 },
            medium: { min: 1, max: 50, count: 7 },
            hard: { min: 1, max: 100, count: 10 }
        };
        
        // æ¸¸æˆé…ç½®
        const gameConfigs = {
            frog: {
                title: 'ğŸ¸ é’è›™è·³è·å¶',
                description: 'å¸®åŠ©å°é’è›™æŒ‰ç…§æ•°å­—é¡ºåºè·³è·å¶å›å®¶ï¼',
                instructions: 'ç‚¹å‡»è·å¶ä¸Šçš„æ•°å­—ï¼ŒæŒ‰ä»å°åˆ°å¤§çš„é¡ºåºå¸®åŠ©é’è›™è·³å›å®¶ï¼'
            },
            monkey: {
                title: 'ğŸµ å°çŒ´åˆ†æ°´æœ',
                description: 'å¸®åŠ©å°çŒ´å­è§£å†³åŠ å‡æ³•é—®é¢˜åˆ†æ°´æœï¼',
                instructions: 'çœ‹é¢˜ç›®é€‰æ‹©æ­£ç¡®ç­”æ¡ˆï¼Œå¸®å°çŒ´å­åˆ†æ°´æœç»™æœ‹å‹ä»¬ï¼'
            },
            balance: {
                title: 'âš–ï¸ æ•°å­—å¤©å¹³',
                description: 'åœ¨å¤©å¹³ä¸¤è¾¹æ”¾æ•°å­—ï¼Œè®©ç­‰å¼æˆç«‹ï¼',
                instructions: 'æ‹–æ‹½æ•°å­—åˆ°å¤©å¹³ä¸Šï¼Œè®©å·¦è¾¹å’Œå³è¾¹ç›¸ç­‰ï¼'
            },
            chain: {
                title: 'ğŸ”— ç®—å¼æ¥é¾™',
                description: 'æŒ‰é¡ºåºç‚¹å‡»ç®—å¼ï¼Œè®©æ•°å­—æ¥é¾™æˆåŠŸï¼',
                instructions: 'ä»èµ·å§‹æ•°å­—å¼€å§‹ï¼ŒæŒ‰ç…§åŠ å‡æ³•è§„å¾‹ç‚¹å‡»ä¸‹ä¸€ä¸ªæ•°å­—ï¼'
            },
            bubble: {
                title: 'ğŸ’­ æ•°å­—æ³¡æ³¡',
                description: 'ç‚¹å‡»æ­£ç¡®ç­”æ¡ˆçš„æ³¡æ³¡ï¼Œè®©å®ƒä»¬æ¶ˆå¤±ï¼',
                instructions: 'è®¡ç®—ç®—å¼ç»“æœï¼Œç‚¹å‡»æ­£ç¡®ç­”æ¡ˆçš„æ³¡æ³¡ï¼'
            },
            car: {
                title: 'ğŸš— æ±½è½¦åœè½¦åœº',
                description: 'æŠŠä¸åŒå½¢çŠ¶çš„æ±½è½¦åœåˆ°å¯¹åº”çš„è½¦ä½ï¼',
                instructions: 'æ‹–æ‹½æ±½è½¦åˆ°ç›¸åŒå½¢çŠ¶çš„è½¦ä½ä¸Šï¼'
            },
            star: {
                title: 'â­ æ˜Ÿæ˜Ÿæ”¶é›†å™¨',
                description: 'æ¯”è¾ƒä¸¤ä¸ªæ•°å­—å¤§å°ï¼Œé€‰æ‹©æ›´å¤§çš„æ”¶é›†æ˜Ÿæ˜Ÿï¼',
                instructions: 'ç‚¹å‡»ä¸¤ä¸ªæ•°å­—ä¸­è¾ƒå¤§çš„é‚£ä¸ªæ¥æ”¶é›†æ˜Ÿæ˜Ÿï¼'
            },
            balloon: {
                title: 'ğŸˆ æ°”çƒé…å¯¹',
                description: 'æ‰¾åˆ°ç›¸åŒæ•°å­—çš„æ°”çƒè®©å®ƒä»¬é…å¯¹ï¼',
                instructions: 'ç‚¹å‡»ä¸¤ä¸ªç›¸åŒæ•°å­—çš„æ°”çƒè®©å®ƒä»¬é…å¯¹æ¶ˆå¤±ï¼'
            }
        };
        
        function switchGame(game) {
            currentGame = game;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.game-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // æ›´æ–°æ¸¸æˆä¿¡æ¯
            const config = gameConfigs[game];
            document.getElementById('gameTitle').textContent = config.title;
            document.getElementById('gameDescription').textContent = config.description;
            document.getElementById('gameInstructions').innerHTML = `<p><strong>æ¸¸æˆè¯´æ˜ï¼š</strong>${config.instructions}</p>`;
            
            // é‡ç½®æ¸¸æˆ
            initGame();
        }
        
        function setDifficulty(level) {
            difficulty = level;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // é‡æ–°åˆå§‹åŒ–æ¸¸æˆ
            initGame();
        }
        
        function updateScore(points) {
            score += points;
            document.getElementById('score').textContent = score;
        }
        
        function updateHint(text) {
            document.getElementById('gameHint').textContent = text;
        }
        
        // æ¸¸æˆåˆå§‹åŒ–
        function initGame() {
            score = 0;
            document.getElementById('score').textContent = score;
            
            switch(currentGame) {
                case 'frog':
                    initFrogGame();
                    break;
                case 'monkey':
                    initMonkeyGame();
                    break;
                case 'balance':
                    initBalanceGame();
                    break;
                case 'chain':
                    initChainGame();
                    break;
                case 'bubble':
                    initBubbleGame();
                    break;
                case 'car':
                    initCarGame();
                    break;
                case 'star':
                    initStarGame();
                    break;
                case 'balloon':
                    initBalloonGame();
                    break;
            }
        }
        
        // é’è›™è·³è·å¶æ¸¸æˆ
        function initFrogGame() {
            const settings = difficultySettings[difficulty];
            const numbers = [];
            
            // ç”Ÿæˆéšæœºæ•°å­—
            while(numbers.length < settings.count) {
                const num = Math.floor(Math.random() * (settings.max - settings.min + 1)) + settings.min;
                if(!numbers.includes(num)) {
                    numbers.push(num);
                }
            }
            
            gameState = {
                numbers: numbers.sort((a, b) => Math.random() - 0.5), // æ‰“ä¹±é¡ºåº
                correctOrder: numbers.sort((a, b) => a - b),
                currentIndex: 0,
                frogX: 50,
                frogY: 300,
                lilypads: []
            };
            
            // ç”Ÿæˆè·å¶ä½ç½®
            for(let i = 0; i < numbers.length; i++) {
                gameState.lilypads.push({
                    x: 150 + (i % 3) * 200 + Math.random() * 50,
                    y: 200 + Math.floor(i / 3) * 150 + Math.random() * 50,
                    number: gameState.numbers[i],
                    clicked: false
                });
            }
            
            updateHint(`ç‚¹å‡»æ•°å­— ${gameState.correctOrder[0]} å¼€å§‹ï¼`);
        }
        
        function drawFrogGame() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#98FB98');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶è·å¶
            gameState.lilypads.forEach(pad => {
                ctx.save();
                ctx.translate(pad.x, pad.y);
                
                // è·å¶
                ctx.fillStyle = pad.clicked ? '#90EE90' : '#228B22';
                ctx.beginPath();
                ctx.ellipse(0, 0, 40, 30, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // æ•°å­—
                ctx.font = 'bold 20px Comic Sans MS';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(pad.number, 0, 0);
                
                ctx.restore();
            });
            
            // ç»˜åˆ¶é’è›™
            drawFrog(gameState.frogX, gameState.frogY);
            
            // ç»˜åˆ¶å®¶
            drawHome(750, 100);
        }
        
        function drawFrog(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // é’è›™èº«ä½“
            ctx.fillStyle = '#32CD32';
            ctx.beginPath();
            ctx.ellipse(0, 0, 25, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼ç›
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-8, -10, 6, 0, Math.PI * 2);
            ctx.arc(8, -10, 6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(-8, -10, 3, 0, Math.PI * 2);
            ctx.arc(8, -10, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawHome(x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(-30, -20, 60, 40);
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.moveTo(0, -40);
            ctx.lineTo(-35, -20);
            ctx.lineTo(35, -20);
            ctx.closePath();
            ctx.fill();
            
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.fillStyle = '#FFD700';
            ctx.textAlign = 'center';
            ctx.fillText('ğŸ ', 0, 0);
            ctx.restore();
        }
        
        // å°çŒ´åˆ†æ°´æœæ¸¸æˆ
        function initMonkeyGame() {
            const settings = difficultySettings[difficulty];
            
            // ç”ŸæˆåŠ å‡æ³•é¢˜ç›®
            const a = Math.floor(Math.random() * (settings.max / 2)) + 1;
            const b = Math.floor(Math.random() * (settings.max / 2)) + 1;
            const operation = Math.random() < 0.5 ? '+' : '-';
            const correctAnswer = operation === '+' ? a + b : Math.max(a, b) - Math.min(a, b);
            
            // ç”Ÿæˆé”™è¯¯ç­”æ¡ˆ
            const wrongAnswers = [];
            while(wrongAnswers.length < 2) {
                const wrong = correctAnswer + (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 5) + 1);
                if(wrong > 0 && wrong !== correctAnswer && !wrongAnswers.includes(wrong)) {
                    wrongAnswers.push(wrong);
                }
            }
            
            const allAnswers = [correctAnswer, ...wrongAnswers].sort(() => Math.random() - 0.5);
            
            gameState = {
                question: `${Math.max(a, b)} ${operation} ${Math.min(a, b)} = ?`,
                correctAnswer: correctAnswer,
                answers: allAnswers,
                fruits: []
            };
            
            // ç”Ÿæˆæ°´æœä½ç½®
            for(let i = 0; i < 3; i++) {
                gameState.fruits.push({
                    x: 300 + i * 150,
                    y: 300,
                    answer: allAnswers[i],
                    type: ['ğŸ', 'ğŸŒ', 'ğŸŠ'][i]
                });
            }
            
            updateHint(`è§£å†³è¿™ä¸ªé—®é¢˜ï¼š${gameState.question}`);
        }
        
        function drawMonkeyGame() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#FFE4B5');
            gradient.addColorStop(1, '#98FB98');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶é¢˜ç›®
            ctx.font = 'bold 30px Comic Sans MS';
            ctx.fillStyle = '#8B4513';
            ctx.textAlign = 'center';
            ctx.fillText(gameState.question, canvas.width / 2, 80);
            
            // ç»˜åˆ¶å°çŒ´å­
            drawMonkey(100, 300);
            
            // ç»˜åˆ¶æ°´æœé€‰é¡¹
            gameState.fruits.forEach(fruit => {
                ctx.save();
                ctx.translate(fruit.x, fruit.y);
                
                // æ°´æœèƒŒæ™¯
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.roundRect(-40, -40, 80, 80, 15);
                ctx.fill();
                
                // æ°´æœå›¾æ ‡
                ctx.font = 'bold 40px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(fruit.type, 0, -10);
                
                // ç­”æ¡ˆæ•°å­—
                ctx.font = 'bold 24px Comic Sans MS';
                ctx.fillStyle = '#8B4513';
                ctx.fillText(fruit.answer, 0, 25);
                
                ctx.restore();
            });
        }
        
        function drawMonkey(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // çŒ´å­èº«ä½“
            ctx.fillStyle = '#DEB887';
            ctx.beginPath();
            ctx.ellipse(0, 0, 30, 40, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // çŒ´å­å¤´
            ctx.beginPath();
            ctx.arc(0, -50, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼ç›
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-8, -55, 5, 0, Math.PI * 2);
            ctx.arc(8, -55, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(-8, -55, 2, 0, Math.PI * 2);
            ctx.arc(8, -55, 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // æ•°å­—å¤©å¹³æ¸¸æˆ
        function initBalanceGame() {
            const settings = difficultySettings[difficulty];
            
            // ç”Ÿæˆç›®æ ‡ç­‰å¼
            const target = Math.floor(Math.random() * (settings.max / 2)) + 5;
            const leftSide = Math.floor(Math.random() * target) + 1;
            const rightSide = target - leftSide;
            
            gameState = {
                target: target,
                leftSide: leftSide,
                rightSide: rightSide,
                leftNumbers: [],
                rightNumbers: [],
                availableNumbers: [],
                draggedNumber: null,
                dragOffset: {x: 0, y: 0},
                balanced: false
            };
            
            // ç”Ÿæˆå¯ç”¨æ•°å­—
            const numbers = [leftSide, rightSide];
            while(numbers.length < 6) {
                const num = Math.floor(Math.random() * settings.max) + 1;
                if(!numbers.includes(num)) {
                    numbers.push(num);
                }
            }
            
            // æ‰“ä¹±é¡ºåºå¹¶åˆ›å»ºå¯ç”¨æ•°å­—
            numbers.sort(() => Math.random() - 0.5);
            for(let i = 0; i < numbers.length; i++) {
                gameState.availableNumbers.push({
                    value: numbers[i],
                    x: 100 + (i % 3) * 100,
                    y: 500 + Math.floor(i / 3) * 60,
                    used: false
                });
            }
            
            updateHint(`è®©å¤©å¹³å¹³è¡¡ï¼ç›®æ ‡ï¼šä¸¤è¾¹éƒ½ç­‰äº ${target}`);
        }
        
        function drawBalanceGame() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#E6E6FA');
            gradient.addColorStop(1, '#F0F8FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶å¤©å¹³
            drawBalance();
            
            // ç»˜åˆ¶å¯ç”¨æ•°å­—
            gameState.availableNumbers.forEach(num => {
                if(!num.used) {
                    drawNumber(num.x, num.y, num.value, '#4169E1');
                }
            });
            
            // ç»˜åˆ¶å¤©å¹³ä¸Šçš„æ•°å­—
            gameState.leftNumbers.forEach((num, index) => {
                drawNumber(250 + index * 40, 250, num, '#32CD32');
            });
            
            gameState.rightNumbers.forEach((num, index) => {
                drawNumber(450 + index * 40, 250, num, '#FF6347');
            });
        }
        
        function drawBalance() {
            // å¤©å¹³æ”¯æ¶
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(400, 150);
            ctx.lineTo(400, 350);
            ctx.stroke();
            
            // å¤©å¹³æ¨ªæ¢
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(200, 200);
            ctx.lineTo(600, 200);
            ctx.stroke();
            
            // å·¦ç›˜
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(250, 250, 80, 0, Math.PI, false);
            ctx.lineTo(330, 250);
            ctx.lineTo(170, 250);
            ctx.closePath();
            ctx.fill();
            
            // å³ç›˜
            ctx.beginPath();
            ctx.arc(550, 250, 80, 0, Math.PI, false);
            ctx.lineTo(630, 250);
            ctx.lineTo(470, 250);
            ctx.closePath();
            ctx.fill();
            
            // æ”¯æ’‘çº¿
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(250, 200);
            ctx.lineTo(250, 250);
            ctx.moveTo(550, 200);
            ctx.lineTo(550, 250);
            ctx.stroke();
            
            // æ˜¾ç¤ºå½“å‰æ€»å’Œ
            const leftSum = gameState.leftNumbers.reduce((sum, num) => sum + num, 0);
            const rightSum = gameState.rightNumbers.reduce((sum, num) => sum + num, 0);
            
            ctx.font = 'bold 24px Comic Sans MS';
            ctx.fillStyle = '#8B4513';
            ctx.textAlign = 'center';
            ctx.fillText(`= ${leftSum}`, 250, 320);
            ctx.fillText(`= ${rightSum}`, 550, 320);
        }
        
        function drawNumber(x, y, value, color) {
            ctx.save();
            ctx.translate(x, y);
            
            // æ•°å­—èƒŒæ™¯
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();
            
            // æ•°å­—
            ctx.font = 'bold 16px Comic Sans MS';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(value, 0, 0);
            
            ctx.restore();
        }
        
        // ç®—å¼æ¥é¾™æ¸¸æˆ
        function initChainGame() {
            const settings = difficultySettings[difficulty];
            
            // ç”Ÿæˆç®—å¼åºåˆ—
            let currentNum = Math.floor(Math.random() * (settings.max / 4)) + 5;
            const operations = ['+', '-'];
            const sequence = [currentNum];
            
            for(let i = 0; i < 4; i++) {
                const operation = operations[Math.random() < 0.5 ? 0 : 1];
                const operand = Math.floor(Math.random() * 10) + 1;
                
                if(operation === '+') {
                    currentNum += operand;
                } else {
                    currentNum = Math.max(1, currentNum - operand);
                }
                
                sequence.push(currentNum);
            }
            
            gameState = {
                sequence: sequence,
                currentIndex: 0,
                chains: [],
                completed: false
            };
            
            // åˆ›å»ºé“¾æ¡ä½ç½®
            for(let i = 0; i < sequence.length; i++) {
                gameState.chains.push({
                    x: 150 + i * 120,
                    y: 300,
                    value: sequence[i],
                    clicked: false,
                    operation: i > 0 ? (sequence[i] > sequence[i-1] ? '+' : '-') : null,
                    operand: i > 0 ? Math.abs(sequence[i] - sequence[i-1]) : null
                });
            }
            
            updateHint(`ä» ${sequence[0]} å¼€å§‹ï¼ŒæŒ‰é¡ºåºç‚¹å‡»ï¼`);
        }
        
        function drawChainGame() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#FFF8DC');
            gradient.addColorStop(1, '#F0E68C');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶é“¾æ¡
            gameState.chains.forEach((chain, index) => {
                ctx.save();
                ctx.translate(chain.x, chain.y);
                
                // é“¾ç¯
                const color = chain.clicked ? '#32CD32' : (index === gameState.currentIndex ? '#FFD700' : '#C0C0C0');
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // æ•°å­—
                ctx.font = 'bold 20px Comic Sans MS';
                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(chain.value, 0, 0);
                
                // æ“ä½œç¬¦
                if(index > 0 && chain.operation) {
                    ctx.font = 'bold 16px Comic Sans MS';
                    ctx.fillStyle = '#8B4513';
                    ctx.fillText(`${chain.operation}${chain.operand}`, -60, -10);
                }
                
                // è¿æ¥çº¿
                if(index < gameState.chains.length - 1) {
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(30, 0);
                    ctx.lineTo(90, 0);
                    ctx.stroke();
                }
                
                ctx.restore();
            });
        }
        
        // æ•°å­—æ³¡æ³¡æ¸¸æˆ
        function initBubbleGame() {
            const settings = difficultySettings[difficulty];
            
            gameState = {
                bubbles: [],
                targetEquation: null,
                correctAnswer: 0,
                poppedCount: 0
            };
            
            // ç”Ÿæˆç®—å¼
            const a = Math.floor(Math.random() * (settings.max / 2)) + 1;
            const b = Math.floor(Math.random() * (settings.max / 2)) + 1;
            const operation = Math.random() < 0.5 ? '+' : '-';
            const correctAnswer = operation === '+' ? a + b : Math.max(a, b) - Math.min(a, b);
            
            gameState.targetEquation = `${Math.max(a, b)} ${operation} ${Math.min(a, b)} = ?`;
            gameState.correctAnswer = correctAnswer;
            
            // ç”Ÿæˆæ³¡æ³¡
            const answers = [correctAnswer];
            while(answers.length < 8) {
                const wrong = correctAnswer + (Math.random() < 0.5 ? -1 : 1) * (Math.floor(Math.random() * 10) + 1);
                if(wrong > 0 && !answers.includes(wrong)) {
                    answers.push(wrong);
                }
            }
            
            // æ‰“ä¹±å¹¶åˆ›å»ºæ³¡æ³¡
            answers.sort(() => Math.random() - 0.5);
            for(let i = 0; i < answers.length; i++) {
                gameState.bubbles.push({
                    x: 150 + (i % 4) * 150,
                    y: 200 + Math.floor(i / 4) * 150,
                    value: answers[i],
                    isCorrect: answers[i] === correctAnswer,
                    popped: false,
                    size: 40,
                    color: `hsl(${Math.random() * 360}, 70%, 80%)`,
                    float: Math.random() * Math.PI * 2
                });
            }
            
            updateHint(`è®¡ç®—ï¼š${gameState.targetEquation}`);
        }
        
        function drawBubbleGame() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶é¢˜ç›®
            ctx.font = 'bold 32px Comic Sans MS';
            ctx.fillStyle = '#4169E1';
            ctx.textAlign = 'center';
            ctx.fillText(gameState.targetEquation, canvas.width / 2, 80);
            
            // ç»˜åˆ¶æ³¡æ³¡
            gameState.bubbles.forEach(bubble => {
                if(!bubble.popped) {
                    const floatY = Math.sin(bubble.float + animationFrame * 0.02) * 3;
                    
                    ctx.save();
                    ctx.translate(bubble.x, bubble.y + floatY);
                    
                    // æ³¡æ³¡ä¸»ä½“
                    ctx.fillStyle = bubble.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, bubble.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // æ³¡æ³¡é«˜å…‰
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(-10, -10, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // æ•°å­—
                    ctx.font = 'bold 24px Comic Sans MS';
                    ctx.fillStyle = 'black';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(bubble.value, 0, 0);
                    
                    ctx.restore();
                }
            });
        }
        
        // æ±½è½¦åœè½¦åœºæ¸¸æˆ
        function initCarGame() {
            const shapes = ['circle', 'square', 'triangle'];
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1'];
            
            gameState = {
                cars: [],
                parkingSpots: [],
                draggedCar: null,
                dragOffset: {x: 0, y: 0}
            };
            
            // ç”Ÿæˆåœè½¦ä½
            for(let i = 0; i < 3; i++) {
                gameState.parkingSpots.push({
                    x: 500 + i * 100,
                    y: 400,
                    shape: shapes[i],
                    occupied: false
                });
            }
            
            // ç”Ÿæˆæ±½è½¦
            const shuffledShapes = [...shapes].sort(() => Math.random() - 0.5);
            for(let i = 0; i < 3; i++) {
                gameState.cars.push({
                    x: 100 + i * 80,
                    y: 200,
                    shape: shuffledShapes[i],
                    color: colors[shapes.indexOf(shuffledShapes[i])],
                    parked: false
                });
            }
            
            updateHint('æ‹–æ‹½æ±½è½¦åˆ°ç›¸åŒå½¢çŠ¶çš„è½¦ä½ï¼');
        }
        
        function drawCarGame() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶èƒŒæ™¯
            ctx.fillStyle = '#F0F0F0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶åœè½¦ä½
            gameState.parkingSpots.forEach(spot => {
                drawParkingSpot(spot);
            });
            
            // ç»˜åˆ¶æ±½è½¦
            gameState.cars.forEach(car => {
                if(!car.parked) {
                    drawCar(car);
                }
            });
        }
        
        function drawParkingSpot(spot) {
            ctx.save();
            ctx.translate(spot.x, spot.y);
            
            // åœè½¦ä½èƒŒæ™¯
            ctx.fillStyle = spot.occupied ? '#90EE90' : '#DCDCDC';
            ctx.fillRect(-40, -30, 80, 60);
            
            // å½¢çŠ¶è½®å»“
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            if(spot.shape === 'circle') {
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
            } else if(spot.shape === 'square') {
                ctx.rect(-15, -15, 30, 30);
            } else if(spot.shape === 'triangle') {
                ctx.moveTo(0, -15);
                ctx.lineTo(-15, 15);
                ctx.lineTo(15, 15);
                ctx.closePath();
            }
            
            ctx.stroke();
            ctx.restore();
        }
        
        function drawCar(car) {
            ctx.save();
            ctx.translate(car.x, car.y);
            
            // æ±½è½¦ä¸»ä½“
            ctx.fillStyle = car.color;
            ctx.fillRect(-25, -15, 50, 30);
            
            // æ±½è½¦å½¢çŠ¶æ ‡è¯†
            ctx.fillStyle = 'white';
            ctx.beginPath();
            
            if(car.shape === 'circle') {
                ctx.arc(0, 0, 10, 0, Math.PI * 2);
            } else if(car.shape === 'square') {
                ctx.rect(-8, -8, 16, 16);
            } else if(car.shape === 'triangle') {
                ctx.moveTo(0, -8);
                ctx.lineTo(-8, 8);
                ctx.lineTo(8, 8);
                ctx.closePath();
            }
            
            ctx.fill();
            
            // è½¦è½®
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(-15, 15, 5, 0, Math.PI * 2);
            ctx.arc(15, 15, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // æ˜Ÿæ˜Ÿæ”¶é›†å™¨æ¸¸æˆ
        function initStarGame() {
            const settings = difficultySettings[difficulty];
            
            const num1 = Math.floor(Math.random() * settings.max) + 1;
            let num2 = Math.floor(Math.random() * settings.max) + 1;
            while(num2 === num1) {
                num2 = Math.floor(Math.random() * settings.max) + 1;
            }
            
            gameState = {
                numbers: [num1, num2],
                correctAnswer: Math.max(num1, num2),
                stars: []
            };
            
            // ç”Ÿæˆæ˜Ÿæ˜Ÿ
            for(let i = 0; i < 10; i++) {
                gameState.stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * 200 + 50,
                    collected: false,
                    twinkle: Math.random() * Math.PI * 2
                });
            }
            
            updateHint(`é€‰æ‹©æ›´å¤§çš„æ•°å­—ï¼š${num1} æˆ– ${num2}`);
        }
        
        function drawStarGame() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶å¤œç©ºèƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#191970');
            gradient.addColorStop(1, '#4B0082');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
            gameState.stars.forEach(star => {
                if(!star.collected) {
                    drawStar(star);
                }
            });
            
            // ç»˜åˆ¶æ•°å­—é€‰é¡¹
            gameState.numbers.forEach((num, index) => {
                ctx.save();
                ctx.translate(200 + index * 400, 400);
                
                // æ•°å­—èƒŒæ™¯
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.roundRect(-60, -60, 120, 120, 20);
                ctx.fill();
                
                // æ•°å­—
                ctx.font = 'bold 48px Comic Sans MS';
                ctx.fillStyle = '#4B0082';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(num, 0, 0);
                
                ctx.restore();
            });
        }
        
        function drawStar(star) {
            ctx.save();
            ctx.translate(star.x, star.y);
            
            const alpha = (Math.sin(star.twinkle + animationFrame * 0.1) + 1) / 2;
            ctx.globalAlpha = alpha * 0.8 + 0.2;
            ctx.fillStyle = '#FFD700';
            
            // ç»˜åˆ¶äº”è§’æ˜Ÿ
            ctx.beginPath();
            for(let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5;
                const x = Math.cos(angle) * 8;
                const y = Math.sin(angle) * 8;
                if(i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
        // æ°”çƒé…å¯¹æ¸¸æˆ
        function initBalloonGame() {
            const settings = difficultySettings[difficulty];
            const numbers = [];
            
            // ç”Ÿæˆé…å¯¹æ•°å­—
            const pairCount = Math.min(4, Math.floor(settings.count / 2));
            for(let i = 0; i < pairCount; i++) {
                const num = Math.floor(Math.random() * settings.max) + 1;
                numbers.push(num, num); // æ·»åŠ ä¸€å¯¹ç›¸åŒçš„æ•°å­—
            }
            
            // æ‰“ä¹±é¡ºåº
            numbers.sort(() => Math.random() - 0.5);
            
            gameState = {
                balloons: [],
                selectedBalloons: [],
                matchedPairs: 0,
                totalPairs: pairCount
            };
            
            // ç”Ÿæˆæ°”çƒ
            numbers.forEach((num, index) => {
                gameState.balloons.push({
                    x: 150 + (index % 4) * 150,
                    y: 150 + Math.floor(index / 4) * 120,
                    number: num,
                    color: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'][index % 4],
                    selected: false,
                    matched: false,
                    float: Math.random() * Math.PI * 2
                });
            });
            
            updateHint('ç‚¹å‡»ä¸¤ä¸ªç›¸åŒæ•°å­—çš„æ°”çƒé…å¯¹ï¼');
        }
        
        function drawBalloonGame() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶å¤©ç©ºèƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶æ°”çƒ
            gameState.balloons.forEach(balloon => {
                if(!balloon.matched) {
                    drawBalloon(balloon);
                }
            });
        }
        
        function drawBalloon(balloon) {
            ctx.save();
            
            const floatY = Math.sin(balloon.float + animationFrame * 0.02) * 5;
            ctx.translate(balloon.x, balloon.y + floatY);
            
            // æ°”çƒç»³å­
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 25);
            ctx.lineTo(0, 60);
            ctx.stroke();
            
            // æ°”çƒä¸»ä½“
            ctx.fillStyle = balloon.selected ? '#FFD700' : balloon.color;
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // æ°”çƒé«˜å…‰
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(-8, -8, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // æ•°å­—
            ctx.font = 'bold 20px Comic Sans MS';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(balloon.number, 0, 0);
            
            ctx.restore();
        }
        
        // äº‹ä»¶å¤„ç†
        canvas.addEventListener('click', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            switch(currentGame) {
                case 'frog':
                    handleFrogClick(x, y);
                    break;
                case 'monkey':
                    handleMonkeyClick(x, y);
                    break;
                case 'balance':
                    handleBalanceClick(x, y);
                    break;
                case 'chain':
                    handleChainClick(x, y);
                    break;
                case 'bubble':
                    handleBubbleClick(x, y);
                    break;
                case 'star':
                    handleStarClick(x, y);
                    break;
                case 'balloon':
                    handleBalloonClick(x, y);
                    break;
            }
        });
        
        // æ‹–æ‹½äº‹ä»¶å¤„ç†ï¼ˆæ±½è½¦æ¸¸æˆå’Œå¤©å¹³æ¸¸æˆï¼‰
        canvas.addEventListener('mousedown', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if(currentGame === 'car') {
                gameState.cars.forEach(car => {
                    if(!car.parked && Math.abs(x - car.x) < 25 && Math.abs(y - car.y) < 15) {
                        gameState.draggedCar = car;
                        gameState.dragOffset = {x: x - car.x, y: y - car.y};
                    }
                });
            } else if(currentGame === 'balance') {
                gameState.availableNumbers.forEach(num => {
                    if(!num.used && Math.abs(x - num.x) < 20 && Math.abs(y - num.y) < 20) {
                        gameState.draggedNumber = num;
                        gameState.dragOffset = {x: x - num.x, y: y - num.y};
                    }
                });
            }
        });
        
        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if(currentGame === 'car' && gameState.draggedCar) {
                gameState.draggedCar.x = x - gameState.dragOffset.x;
                gameState.draggedCar.y = y - gameState.dragOffset.y;
            } else if(currentGame === 'balance' && gameState.draggedNumber) {
                gameState.draggedNumber.x = x - gameState.dragOffset.x;
                gameState.draggedNumber.y = y - gameState.dragOffset.y;
            }
        });
        
        canvas.addEventListener('mouseup', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if(currentGame === 'car' && gameState.draggedCar) {
                // æ£€æŸ¥æ˜¯å¦æ”¾åˆ°äº†æ­£ç¡®çš„åœè½¦ä½
                gameState.parkingSpots.forEach(spot => {
                    if(!spot.occupied && 
                       Math.abs(x - spot.x) < 40 && 
                       Math.abs(y - spot.y) < 30 &&
                       spot.shape === gameState.draggedCar.shape) {
                        
                        gameState.draggedCar.parked = true;
                        spot.occupied = true;
                        updateScore(10);
                        
                        // æ£€æŸ¥æ˜¯å¦å…¨éƒ¨åœå¥½
                        if(gameState.cars.every(car => car.parked)) {
                            setTimeout(() => {
                                alert('ğŸ‰ å¤ªæ£’äº†ï¼æ‰€æœ‰æ±½è½¦éƒ½åœå¥½äº†ï¼');
                                initGame();
                            }, 500);
                        }
                    }
                });
                
                gameState.draggedCar = null;
            } else if(currentGame === 'balance' && gameState.draggedNumber) {
                // æ£€æŸ¥æ˜¯å¦æ”¾åˆ°å¤©å¹³ä¸Š
                if(x > 170 && x < 330 && y > 200 && y < 300) {
                    // æ”¾åˆ°å·¦ç›˜
                    gameState.leftNumbers.push(gameState.draggedNumber.value);
                    gameState.draggedNumber.used = true;
                } else if(x > 470 && x < 630 && y > 200 && y < 300) {
                    // æ”¾åˆ°å³ç›˜
                    gameState.rightNumbers.push(gameState.draggedNumber.value);
                    gameState.draggedNumber.used = true;
                }
                
                // æ£€æŸ¥æ˜¯å¦å¹³è¡¡
                const leftSum = gameState.leftNumbers.reduce((sum, n) => sum + n, 0);
                const rightSum = gameState.rightNumbers.reduce((sum, n) => sum + n, 0);
                
                if(leftSum === rightSum && leftSum === gameState.target) {
                    updateScore(25);
                    updateHint('å¤ªæ£’äº†ï¼å¤©å¹³å¹³è¡¡äº†ï¼');
                    setTimeout(() => {
                        alert('ğŸ‰ æ­å–œï¼å¤©å¹³å®Œç¾å¹³è¡¡ï¼');
                        initGame();
                    }, 1000);
                } else if(leftSum > 0 || rightSum > 0) {
                    updateHint(`å·¦è¾¹ï¼š${leftSum}ï¼Œå³è¾¹ï¼š${rightSum}ï¼Œç›®æ ‡ï¼š${gameState.target}`);
                }
                
                gameState.draggedNumber = null;
            }
        });
        
        // å„æ¸¸æˆçš„ç‚¹å‡»å¤„ç†å‡½æ•°
        function handleFrogClick(x, y) {
            gameState.lilypads.forEach(pad => {
                if(Math.abs(x - pad.x) < 40 && Math.abs(y - pad.y) < 30 && !pad.clicked) {
                    if(pad.number === gameState.correctOrder[gameState.currentIndex]) {
                        pad.clicked = true;
                        gameState.currentIndex++;
                        updateScore(10);
                        
                        // ç§»åŠ¨é’è›™
                        gameState.frogX = pad.x;
                        gameState.frogY = pad.y;
                        
                        if(gameState.currentIndex < gameState.correctOrder.length) {
                            updateHint(`å¾ˆå¥½ï¼ç°åœ¨ç‚¹å‡»æ•°å­— ${gameState.correctOrder[gameState.currentIndex]}`);
                        } else {
                            updateHint('å¤ªæ£’äº†ï¼é’è›™å›å®¶äº†ï¼');
                            setTimeout(() => {
                                alert('ğŸ‰ æ­å–œï¼é’è›™æˆåŠŸå›å®¶äº†ï¼');
                                initGame();
                            }, 1000);
                        }
                    } else {
                        updateHint(`ä¸å¯¹å“¦ï¼Œåº”è¯¥ç‚¹å‡»æ•°å­— ${gameState.correctOrder[gameState.currentIndex]}`);
                    }
                }
            });
        }
        
        function handleMonkeyClick(x, y) {
            gameState.fruits.forEach(fruit => {
                if(Math.abs(x - fruit.x) < 40 && Math.abs(y - fruit.y) < 40) {
                    if(fruit.answer === gameState.correctAnswer) {
                        updateScore(15);
                        updateHint('å¤ªæ£’äº†ï¼ç­”æ¡ˆæ­£ç¡®ï¼');
                        setTimeout(() => {
                            alert('ğŸ‰ å°çŒ´å­å¾ˆå¼€å¿ƒï¼ç­”æ¡ˆæ­£ç¡®ï¼');
                            initGame();
                        }, 1000);
                    } else {
                        updateHint('ä¸å¯¹å“¦ï¼Œå†æƒ³æƒ³çœ‹ï¼');
                    }
                }
            });
        }
        
        function handleStarClick(x, y) {
            gameState.numbers.forEach((num, index) => {
                const centerX = 200 + index * 400;
                const centerY = 400;
                
                if(Math.abs(x - centerX) < 60 && Math.abs(y - centerY) < 60) {
                    if(num === gameState.correctAnswer) {
                        // æ”¶é›†æ‰€æœ‰æ˜Ÿæ˜Ÿ
                        gameState.stars.forEach(star => star.collected = true);
                        updateScore(20);
                        updateHint('å¤ªæ£’äº†ï¼æ”¶é›†äº†æ‰€æœ‰æ˜Ÿæ˜Ÿï¼');
                        
                        setTimeout(() => {
                            alert('ğŸ‰ æ­å–œï¼ä½ é€‰æ‹©äº†æ›´å¤§çš„æ•°å­—ï¼');
                            initGame();
                        }, 1000);
                    } else {
                        updateHint('ä¸å¯¹å“¦ï¼Œé€‰æ‹©æ›´å¤§çš„æ•°å­—ï¼');
                    }
                }
            });
        }
        
        function handleBalloonClick(x, y) {
            gameState.balloons.forEach(balloon => {
                if(!balloon.matched && Math.abs(x - balloon.x) < 25 && Math.abs(y - balloon.y) < 25) {
                    if(gameState.selectedBalloons.length < 2) {
                        balloon.selected = true;
                        gameState.selectedBalloons.push(balloon);
                        
                        if(gameState.selectedBalloons.length === 2) {
                            const [first, second] = gameState.selectedBalloons;
                            
                            if(first.number === second.number) {
                                // é…å¯¹æˆåŠŸ
                                first.matched = true;
                                second.matched = true;
                                gameState.matchedPairs++;
                                updateScore(15);
                                
                                if(gameState.matchedPairs === gameState.totalPairs) {
                                    setTimeout(() => {
                                        alert('ğŸ‰ å¤ªæ£’äº†ï¼æ‰€æœ‰æ°”çƒéƒ½é…å¯¹æˆåŠŸäº†ï¼');
                                        initGame();
                                    }, 1000);
                                }
                            } else {
                                // é…å¯¹å¤±è´¥ï¼Œé‡ç½®é€‰æ‹©
                                setTimeout(() => {
                                    first.selected = false;
                                    second.selected = false;
                                }, 1000);
                            }
                            
                            gameState.selectedBalloons = [];
                        }
                    }
                }
            });
        }
        
        function handleBalanceClick(x, y) {
            // æ£€æŸ¥ç‚¹å‡»çš„æ•°å­—
            gameState.availableNumbers.forEach(num => {
                if(!num.used && Math.abs(x - num.x) < 20 && Math.abs(y - num.y) < 20) {
                    // ç®€åŒ–ï¼šç‚¹å‡»æ•°å­—ç›´æ¥æ·»åŠ åˆ°å·¦ç›˜
                    gameState.leftNumbers.push(num.value);
                    num.used = true;
                    
                    // æ£€æŸ¥æ˜¯å¦å¹³è¡¡
                    const leftSum = gameState.leftNumbers.reduce((sum, n) => sum + n, 0);
                    const rightSum = gameState.rightNumbers.reduce((sum, n) => sum + n, 0);
                    
                    if(leftSum === gameState.target && rightSum === 0) {
                        // è¿˜éœ€è¦å³è¾¹
                        updateHint(`å¾ˆå¥½ï¼ç°åœ¨å³è¾¹ä¹Ÿéœ€è¦ç­‰äº ${gameState.target}`);
                    } else if(leftSum === gameState.target && rightSum === gameState.target) {
                        updateScore(25);
                        updateHint('å¤ªæ£’äº†ï¼å¤©å¹³å¹³è¡¡äº†ï¼');
                        setTimeout(() => {
                            alert('ğŸ‰ æ­å–œï¼å¤©å¹³å®Œç¾å¹³è¡¡ï¼');
                            initGame();
                        }, 1000);
                    } else if(leftSum > gameState.target) {
                        updateHint('å·¦è¾¹å¤ªé‡äº†ï¼Œè¯•è¯•å…¶ä»–ç»„åˆï¼');
                        setTimeout(() => initGame(), 1500);
                    }
                }
            });
            
            // ç®€åŒ–ç‰ˆæœ¬ï¼šç‚¹å‡»å³ç›˜åŒºåŸŸæ·»åŠ åˆ°å³ç›˜
            if(x > 470 && x < 630 && y > 200 && y < 300) {
                gameState.availableNumbers.forEach(num => {
                    if(!num.used) {
                        gameState.rightNumbers.push(num.value);
                        num.used = true;
                        
                        const leftSum = gameState.leftNumbers.reduce((sum, n) => sum + n, 0);
                        const rightSum = gameState.rightNumbers.reduce((sum, n) => sum + n, 0);
                        
                        if(leftSum === rightSum && leftSum === gameState.target) {
                            updateScore(25);
                            updateHint('å¤ªæ£’äº†ï¼å¤©å¹³å¹³è¡¡äº†ï¼');
                            setTimeout(() => {
                                alert('ğŸ‰ æ­å–œï¼å¤©å¹³å®Œç¾å¹³è¡¡ï¼');
                                initGame();
                            }, 1000);
                        }
                        return;
                    }
                });
            }
        }
        
        function handleChainClick(x, y) {
            gameState.chains.forEach((chain, index) => {
                if(Math.abs(x - chain.x) < 30 && Math.abs(y - chain.y) < 30) {
                    if(index === gameState.currentIndex) {
                        chain.clicked = true;
                        gameState.currentIndex++;
                        updateScore(10);
                        
                        if(gameState.currentIndex < gameState.chains.length) {
                            updateHint(`å¾ˆå¥½ï¼ä¸‹ä¸€ä¸ªæ˜¯ ${gameState.chains[gameState.currentIndex].value}`);
                        } else {
                            updateHint('å¤ªæ£’äº†ï¼ç®—å¼æ¥é¾™å®Œæˆï¼');
                            gameState.completed = true;
                            setTimeout(() => {
                                alert('ğŸ‰ æ­å–œï¼ç®—å¼æ¥é¾™æˆåŠŸå®Œæˆï¼');
                                initGame();
                            }, 1000);
                        }
                    } else {
                        updateHint(`ä¸å¯¹å“¦ï¼Œåº”è¯¥ç‚¹å‡» ${gameState.chains[gameState.currentIndex].value}`);
                    }
                }
            });
        }
        
        function handleBubbleClick(x, y) {
            gameState.bubbles.forEach(bubble => {
                if(!bubble.popped && Math.abs(x - bubble.x) < bubble.size && Math.abs(y - bubble.y) < bubble.size) {
                    if(bubble.isCorrect) {
                        bubble.popped = true;
                        gameState.poppedCount++;
                        updateScore(15);
                        updateHint('å¤ªæ£’äº†ï¼ç­”æ¡ˆæ­£ç¡®ï¼');
                        
                        setTimeout(() => {
                            alert('ğŸ‰ æ­å–œï¼ä½ æ‰¾åˆ°äº†æ­£ç¡®ç­”æ¡ˆï¼');
                            initGame();
                        }, 1000);
                    } else {
                        updateHint('ä¸å¯¹å“¦ï¼Œå†æƒ³æƒ³çœ‹ï¼');
                        // é”™è¯¯çš„æ³¡æ³¡ä¹Ÿä¼šæ¶ˆå¤±ï¼Œä½†ä¸å¾—åˆ†
                        bubble.popped = true;
                    }
                }
            });
        }
        
        // æ¸¸æˆä¸»å¾ªç¯
        function gameLoop() {
            switch(currentGame) {
                case 'frog':
                    drawFrogGame();
                    break;
                case 'monkey':
                    drawMonkeyGame();
                    break;
                case 'balance':
                    drawBalanceGame();
                    break;
                case 'chain':
                    drawChainGame();
                    break;
                case 'bubble':
                    drawBubbleGame();
                    break;
                case 'car':
                    drawCarGame();
                    break;
                case 'star':
                    drawStarGame();
                    break;
                case 'balloon':
                    drawBalloonGame();
                    break;
            }
            
            animationFrame++;
            requestAnimationFrame(gameLoop);
        }
        
        // æ·»åŠ åœ†è§’çŸ©å½¢æ”¯æŒ
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
                this.beginPath();
                this.moveTo(x + radius, y);
                this.lineTo(x + width - radius, y);
                this.quadraticCurveTo(x + width, y, x + width, y + radius);
                this.lineTo(x + width, y + height - radius);
                this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                this.lineTo(x + radius, y + height);
                this.quadraticCurveTo(x, y + height, x, y + height - radius);
                this.lineTo(x, y + radius);
                this.quadraticCurveTo(x, y, x + radius, y);
                this.closePath();
            };
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        initGame();
        gameLoop();
    </script>
</body>
</html> 